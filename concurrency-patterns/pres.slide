Concurrency Patterns in Go
How to keep your sanity. And your hair
26 May 2015
Tags: Go, Golang, Programming Languages, Concurrency

Aaron Schlesinger
Sr. Engineer, Iron.io
aaron@iron.io
arschles@gmail.com
http://iron.io
http://github.com/arschles
@arschles

* About Me

- Database & backend systems engineer at Iron.io
- Writing Go for ~2 yrs, JVM for a while before that
- Distributed systems at Zynga, StackMob, PayPal, now Iron
- Go. I'm finally happy

* Today

- Patterns for locks & channels
- [[http://blog.golang.org/go-concurrency-patterns-timing-out-and][Timeouts]] & [[http://godoc.org/golang.org/x/net/context][net.Context]]
- For-select loops

* "It's almost too easy to write concurrency bugs in Go"

Because Go has powerful concurrency primitives.

I'm discussing today how to use them responsibly.

This talk is mostly aimed toward library authors.

* Something old

We (Iron.io) still use locks.

Prefer "sharing memory by communicating" but if you must use locks:

.image maintainer-serial-killer.jpg

* Specifically, here's what I think

- `defer` unlocking wherever possible
- document ownership in your *public* interface
- if mutual exclusion crosses a public interface boundary, abstract it

Also, good conventions already exist from other communities (e.g. standard locking order)

* Documentation

.code request_ids.go

* Channels

 share memory by communicating.

Channels are simple to understand but powerful enough to build real systems.

Use them by default and, when in doubt, convince yourself why you _shouldn't_
use them to build your concurrent system

* Specifically

- TODO: preach about documentation here
- Enlist the compiler. Use directional channels
- `close` is a useful signal, use it and document it

* Example

.code channels.go

* Select

In a Go state of the union talk (I think), Rob said concurrency & message passing
are only useful with `select`.

I agree with this statement.

If you're building a concurrent library, give callers plenty of channels to
communicate with your library.

* Example
TODO

* WaitGroup

`sync.WaitGroup` is true to its name. Remember the fan-in pattern.

//TODO: datastore code to do many queries and collate results

* Timeouts & Context

`net.Context` does a lot of the work for you. If you are waiting for a channel, prefer
to also time out. Pass a context so the timeout is easily configurable (and testable).

//TODO: simple code for waiting

* For-select loops

Often used as event loops. `select` on 1+ channels, do work, loop (maybe forever)

- ack before and after real work is done. testing is easier and rate limiting/backpressure is easy
- if you're ticking, build acks into `time.Ticker`
- `net.Context` for cancellation
- `sync.WaitGroup` for started and stopped loops
